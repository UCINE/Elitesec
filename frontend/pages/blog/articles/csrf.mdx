---
title: CSRF (Cross-Site Request Forgery)
date: 2024-02-25
description: A comprehensive guide to understanding CSRF attacks, their impact, and prevention mechanisms including SameSite cookies and Same Origin Policy.
category: Web Security
author:
    name: Mohsine El Hadaoui
    href: https://github.com/m0hs1ne
---
# ğŸ’â€â™‚ï¸ CSRF

> CSRF is an attack that tricks the victim into submitting a malicious request.

### What is Cross-Site Request Forgery (CSRF)? <a href="#what-is-cross-site-request-forgery-csrf" id="what-is-cross-site-request-forgery-csrf"></a>

Cross-Site Request Forgery (CSRF) is an attack that tricks users of a web application into unknowingly performing unwanted actions while they are authenticated. This type of attack targets requests that change the applicationâ€™s state, rather than stealing data. Because the attacker cannot see the response to the forged request, they rely on social engineering techniques, such as sending malicious links via email or chat, to deceive users into executing actions of the attackerâ€™s choosing.

![image](https://i.ibb.co/C9xLpKY/pinterestdownloader-com-1691670824-925069.jpg)

### Impact of CSRF attacks: <a href="#impact-of-csrf-attacks" id="impact-of-csrf-attacks"></a>

If the victim is a regular user, a successful CSRF attack can lead to state-changing requests being performed without their consent. This can include actions like transferring funds, changing their email address, or giving an attacker access to their data. On the other hand, if the victim has an administrative account, a CSRF attack can compromise the entire web application.

### Understanding CSRF Attacks <a href="#understanding-csrf-attacks" id="understanding-csrf-attacks"></a>

Cross-Site Request Forgery (CSRF) attacks allow attackers to bypass authentication processes or perform actions with elevated privileges. To execute this type of attack, the attacker must:

1. Create a custom payload.
2. Embed the request into a hyperlink.
3. Trick the victim into clicking the link, which sends the request to the website.
4. Forge the request to conduct malicious actions.

CSRF attacks only work if the victim is an authenticated user. This is because, when the request is made, the application checks if valid session cookies are available. If relevant cookies are available and sent with the request, and the website approves them, the CSRF attack will be successful.

### CSRF Attack Example <a href="#csrf-attack-example" id="csrf-attack-example"></a>

Letâ€™s say that a user is logged into their bank account and wants to transfer money to another account. The userâ€™s bank uses a GET request to transfer funds, which is vulnerable to CSRF attacks. The attacker creates a malicious link like this:

`https://bank.com/transfer?to=attacker&amount=1000`

when clicked, transfers money from the victimâ€™s account to the attackerâ€™s account. The attacker then sends the link to the victim via email or chat. If the victim clicks the link, the request is sent to the bankâ€™s website, which approves the request because the victim is already authenticated. The attacker receives the money, and the victim is none the wiser.

If the attacker is sending the payload with a POST request, a payload similar to the following HTML code can be used:

```
<html>
<body>
<form action="http://bank.co m/transfer" method="post">
<input type="hidden" name="Transaction" value="withdraw" />
<input type="hidden" name="Amount" value="3000000" />
<input type="submit" value="Click"/>
</form>
</body>
</html>
```

When using the â€œbank.com/transferâ€ endpoint to perform a transfer action, the â€œTransactionâ€ and â€œAmountâ€ parameters are passed via a POST request. Since this endpoint doesnâ€™t require a random CSRF token, an attacker can put HTML code on â€œattacker.com,â€ send the link to the victim, and initiate a transfer once the victim opens the link. This attack is possible due to the lack of mandatory CSRF token.

### what is CSRF token? <a href="#what-is-csrf-token" id="what-is-csrf-token"></a>

A CSRF token is a unique, secret, unpredictable value that is generated by the server-side application and transmitted to the client in such a way that it is included in a subsequent HTTP request made by the client. When the later request is made, the server-side application validates that the request includes the expected token and rejects the request if the token is missing or invalid.

### is CSRF simple as it looks? <a href="#is-csrf-simple-as-it-looks" id="is-csrf-simple-as-it-looks"></a>

When the victim opens the link, the transfer occurs. Right?

Well, itâ€™s not that simple.

There are various scenarios to consider. For instance, if the victim is using Chrome browser, it wonâ€™t work. However, if they are using Safari, it would work. So, can we conclude that CSRF doesnâ€™t occur in Chrome anymore? No. It depends on whether the victim logged in to `bank.com` within the last two minutes. If they did, the transfer will work. If more than two minutes have passed, it wonâ€™t.

Furthermore, whether the â€œbank.com/transferâ€ endpoint accepts the content-type as â€œtext/htmlâ€ determines whether it will work or not. If it only accepts â€œapplication/json,â€ it wonâ€™t work.

![](https://i.pinimg.com/originals/f1/60/94/f160944c79c3d9ea8acc36f007f45c6b.jpg)

I understand that it may be confusing. To understand these scenarios, we must first grasp two concepts: SameSite Cookies and Same Origin Policy. Letâ€™s break it down step by step.

### SameSite Cookies <a href="#samesite-cookies" id="samesite-cookies"></a>

SameSite is a cookie attribute, similar to HttpOnly and Secure. Its purpose is to address the main vulnerability exploited by CSRF attacks. By default, when you send a request from a.com to b.com, the browser includes your cookies for b.com in the request. As a result, when the attackerâ€™s code on evil.com sends a money transfer request to bank.com, the browser sends an authenticated request to bank.com, leading to the successful transfer.

If the browser fails to add the cookie to the request, it poses a problem. Letâ€™s consider a scenario where a victim logs in to bank.com, then visits evil.com. Inside evil.com, a transfer request is sent to bank.com. However, because the browser doesnâ€™t include cookies, the request lacks the necessary authentication, resulting in the transfer not taking place.

To address this issue, a concept called â€œSameSiteâ€ has been introduced. The SameSite cookie attribute offers three possible values:

Lax: Cookies are not sent with normal cross-site requests, unless the user is navigating to the original site (e.g., by following a link).

Strict: Cookies are only sent in a first-party context and are not included in requests initiated by third-party websites.

None: Cookies are sent in all contexts, regardless of whether the request is cross-site or first-party.

Developers have the option to set Lax or Strict flags as protection against CSRF attacks. However, what happens if they neglect to do so? Letâ€™s refer back to our previous example:

`"if the victim is using Chrome browser, it won't work. However, if they are using Safari, it would work."`

The reason behind this is that the Chrome browser automatically applies a default SameSite value (Lax) to cookies. As a result, even if the developer is unaware of CSRF or SameSite cookies, their websites are still safeguarded, and CSRF attacks are prevented. Letâ€™s put this to the test.

Using the Chrome browser, navigate to [https://authenticationtest.com/simpleFormAuth/](https://authenticationtest.com/simpleFormAuth/) and complete the form by entering the provided username and password values.

Once logged in, the application will generate a session cookie. You can verify its presence in Chromeâ€™s developer console. Notably, the cookie does not contain a SameSite attribute.

![Image](https://i.ibb.co/XJq6y30/image-2023-08-10-154220483.png)

There is a form that we can test at [https://authenticationtest.com/xssDemo/](https://authenticationtest.com/xssDemo/) . Just fill the textbox and click the â€œSearchâ€ button. It generates a POST request and the request doesnâ€™t contain a random CSRF-token. So in theory, we can conduct a CSRF attack there.

Save the following HTML snippet as csrf.html and open it in the same Chrome browser that you logged in.

```
<html>
 <body>
 <script>history.pushState(â€˜â€™, â€˜â€™, â€˜/â€™)</script>
 <form action=â€https://authenticationtest.com/xssDemo/" method=â€POSTâ€>
 <input type=â€hiddenâ€ name=â€searchâ€ value=â€requestTestâ€ />
 <input type=â€submitâ€ value=â€Submit requestâ€ />
 </form>
 </body>
</html>
```

Open Chromeâ€™s developer console and go to the â€œNetworkâ€ section. Then, click the â€œSubmit Requestâ€ button. what happened? the POST request sent with our authentication cookie.

![Image](https://i.ibb.co/280qLYS/image-2023-08-10-160541677.png)

Was that wrong? Does Chrome not always set the Lax attribute? If it doesnâ€™t, then this request shouldnâ€™t have the cookie.

Now things get a bit tricky. Letâ€™s remember what I showed you earlier:

â€œIf the user logged into bank.com just 2 minutes ago, the CSRF attack will work. But if itâ€™s been more than 2 minutes, the CSRF attack wonâ€™t work.â€

Basically, Chrome only sends the cookie within 2 minutes of authentication; after that, it stops sending it.

![Image](https://i.pinimg.com/originals/19/98/2b/19982b821761e764b7f90d440ee1247a.jpg)

Please wait for 2 minutes before resending the request using csrf.html. Notice any changes? This time, the request doesnâ€™t include the cookie.

![Image](https://i.ibb.co/NTCFgfb/image-2023-08-10-161748778.png)

why there is such a behavior? When Chrome started to set SameSite attribute to Lax by default, it caused issues with certain aspects of the web.

Certain applications like OAuth, OpenID, and payment gateways depend on cross-site requests for their functioning. Without this capability, the entire process breaks. To address this, Chrome developers introduced a temporary solution known as the â€œ2-minute rule.â€ This rule allows these processes to operate smoothly. However, itâ€™s important to note that this solution is only temporary, and the upcoming change will make SameSite=Lax the default setting for all scenarios.

So, if the victim uses a Safari browser and the â€œbank.com/transferâ€ endpoint doesnâ€™t require any CSRF tokens, we can exploit it, right.

Well, itâ€™s not that simple.

### Same Origin Policy <a href="#same-origin-policy" id="same-origin-policy"></a>

I wonâ€™t get into all the technical details of the Same Origin Policy, as it can be quite complex. Instead, Iâ€™ll talk about how it relates to CSRF and clear up a common misconception:

Some folks think the Same Origin Policy only stops â€œa.comâ€ from grabbing data from â€œb.com,â€ but lets requests from â€œa.comâ€ go to â€œb.com.â€

Actually, thatâ€™s not entirely correct. The SOP mostly stops data reading, but sometimes it also limits sending data.

So what kind of requests are allowed?

It allows sending GET/POST requests through HTML forms. Letâ€™s try the following example:

```
<html>
 <body>
 <script>history.pushState(â€˜â€™, â€˜â€™, â€˜/â€™)</script>
 
<form action=â€https://example.com/" method=â€POSTâ€>

 <input type=â€hiddenâ€ name=â€amountâ€ value=â€500" />
 <input type=â€submitâ€ value=â€Submit requestâ€ />
 </form>
 </body>
</html>
```

Requestâ€™s content-type will be â€œapplication/x-www-form-urlencodedâ€ which is allowed by SOP. Therefore, the request is sent.

![Image](https://i.ibb.co/TDGnZbh/image-2023-08-10-171723577.png)

This feature prevents PUT requests as well as requests with the â€œapplication/jsonâ€ Content-Type header.

You cannot initiate PUT or â€œContent-Type: application/jsonâ€ requests using HTML forms. Instead, these require a distinct approach known as a â€œspecial request.â€ To accomplish this, you can employ the XMLHttpRequest (XHR) method in JavaScript. Letâ€™s explore an illustrative example below:

```
<!DOCTYPE html>
<html lang="en">
<body>
    <script>
        var xmlhttp = new XMLHttpRequest();
        var theUrl = "https://mychaos.me/transfer";
        xmlhttp.open("POST", theUrl);
        xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");

        xmlhttp.send(JSON.stringify({ "amount": "500" }));
    </script>
</body>
</html>
```

The above code will send a POST request to the â€œ[https://mychaos.me/transfer"](https://mychaos.me/transfer%22) endpoint with the â€œamountâ€ parameter set to 500. The request failed due to â€œCORS errorâ€. So, what happened behind the scene?

Since this is an XHR request, the browser sends a â€œpreflightâ€ request to the target website with â€œOPTIONSâ€ method. The browser makes this request to understand if the target website allows this request. How a website can allow this request? With Cross-Origin Resource Sharing (CORS) header of course. If the target website had â€œAccess-Control-Allow-Origin: \*â€ response header, the request would be successful.

So, we can say that:

* If the â€œbank.com/transferâ€ endpoint only accepts â€œapplication/jsonâ€ content-type, it doesnâ€™t need any CSRF tokens. The attack wonâ€™t work.
* If the â€œbank.com/transferâ€ endpoint only accepts â€œPUTâ€ requests, it doesnâ€™t need any CSRF tokens. The attack wonâ€™t work.

![Image](https://i.ibb.co/mt9vXd0/image-2023-08-10-173943705.png)

But of course, we shouldnâ€™t forget that there might be wrong implementations on the code base. What if â€œbank.com/transferâ€ accepts GET requests as well mistakenly? We can exploit it with:

```
<img src=â€https://mychaos.me/?amount=500">
```

img or script donâ€™t require preflight requests.

### Conclusion <a href="#conclusion" id="conclusion"></a>

Cookies are vulnerable as they are automatically sent with each request, allowing attackers to easily craft malicious requests leading to CSRF. Although the attacker cannot obtain the response body or the Cookie itself, the attacker can perform actions with the victimâ€™s elevated rights. The impact of a CSRF vulnerability is also related to the privilege of the victim, whose Cookie is being sent with the attackerâ€™s request. While data retrieval is not the main scope of a CSRF attack, state changes will surely have an adverse effect on the web application being exploited.